---
title: "Simulation von Zufallszahlen"
subtitle: "Vorlesung: Computerintensive Methoden SS 2017"
author: 
- "Bernhard Preisler (734631)"
- "[Hendrik Pfaff](http://hendrik-pfaff.de) (725837)"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
tags: [Vorlesung, Computational Statistics, Zufallszahlen, Zufallsvariablen, Simulation]
output:
  pdf_document:
    toc: true
---

\newpage
# Motiviation
Zufallszahlen spielen eine wichtige Rolle in Wissenschaft, Technik und Industrie. Sie werden beispielsweise in der Kryptographie bei der Wahl eines Schlüssels, bei Computersimulationen zur Erzeugung von unvorhergesehenen Ereingissen oder in der statistischen Analyse bei der Auswahl von Stichproben benutzt.  
Die Erzeugung von Zufälligkeiten in einem Computer (ein deterministischer Automat) stellt allerdings eine besondere Herausforderung dar, da jede Operation durch die Vorherige definiert wird und daher (theoretisch) berechenbar ist.

# Definitionen
Um möglichen Verwirrungen vorzubeugen, werden in diesen Kapitel Begrifflichkeiten in Bezug aus das Thema Simulation von Zufallszahlen eingeführt und abgegrenzt.

## Simulation

## Zufallsvariablen \& Zufallszahlen
Eine \textbf{Zufallsvariable} ist eine Variable, die die Wahrscheinlichkeit eines noch nicht durchgeführten Experiments beschreibt. Beispielsweise kann solch eine Zufallsvariable den Wurf eines fairen sechseitigen Würfels beschreiben. Die Wahrscheinlichkeit für den Ausgang eines bestimmten Ergebnis ist in diesem Beispiel gleichverteilt. Das Ergebnis wird als \textbf{Zufallszahl} beschrieben. Mathematisch wird eine Zufallsvariable mit einem Großbuchstaben $X$, $Y$, $Z$ und eine Zufallszahl mit einen Kleinbuchstaben $x$ betitelt.

## Nichtdeterministische \& deterministische Zufallsgeneratoren
Das Ergebnis eines Algorithmus verändert sich bei gleichbleibenden Eingaben nicht. Demnach lässt sich eine komplett zufällige Funktion rein durch Software nicht realisieren. Eine Möglichkeit dieses Problem zu lösen ist es bestimmte physikalische Prinzipien miteinzubeziehen. Durch deren gegebene Zufälligkeit lassen sich Funktionen erstellen, die zu ebenso zufälligen Ergebnissen führen. Dieses Prinzip nennt sich \emph{Nichtdeterminismus} und diese Art von Generatoren werden die \textbf{nichtdeterministische Zufallsgenerator} genannt.\newline

Hierzu wird oft Hardware verwendet, die durch Sensoren physikalische Effekte messen kann. Unter anderem: 

* Radioaktiver Zerfall
* Wärmerauschen
* zufällige quantenmechanische Vorgänge
* Atmosphärenrauschen (wie analoges Radio, das nicht auf einen Sender abgestimmt ist)

\begin{figure}[ht]
	\centering
  \includegraphics[width=100px, height=100px]{img/FST-01_board.png}
	\caption {Der Flying Stone Technology FST-01 erzeugt echte Zufallszahlen aus dem Rauschen bei der Analog-Digital Signalumwandlung.}
	\label{fig2}
\end{figure}

Allerdings müssen physikalische Beobachtunge (um die Zahlen zu generieren) in einem angemessen großen Abstand zueinander erfolgen um Unabhängigkeit zu gewährleisten

Demnach zeichnen sich die \textbf{deterministischen Zufallsgeneratoren} dadurch aus, dass bei gleicher Eingabe immer der selber Ausgang berechnet wird. Die so erzeugten Zahlen werden \textbf{Pseudozufallszahlen} genannt.

# Erzeugen von (Pseudo)Zufallszahlen

Bevor mit dem Bau eines deterministischer Zufallsgenerators begonnen wird, stellt sich die Frage, welches Ziel ein solcher Zufallsgenerator erfüllen soll. Umgangsprachlich kann ein Ziel für die Simulation von Zufallszahlen auf einen Rechner folglich definiert werden:

> \textbf{"... ein auf einem Rechner ablauffähiges Zufallsexperiment zu erhalten, ..."}, Michael Kolonk

Weiterhin besteht die Möglichkeit die Definition auf einer mathemathischen Ebene zu heben.

> Eine Folge von iid. Zufallsvariablen $(X_n)_{n\geq0}$ mit $U(0,1)$, Michael Kolonk

Alle Pseudozufallsgeneratoren kommen an einer Position an, wo sich die pseudo zufällig generierten Zahlen wiederholen. Dies wird als \textbf{Periodenlänge} bezeichnet. Ein gutes Beispiel ist der Generator $x_{n+1} := (5x_n + 1)\ MOD\ 8$. Wird $x_0 = 1$ gesetzt, werden die Zahlenfolge $1,6,7,4,5,2,3,0,1,6,7\ ...$ generiert. Die maximale Periodenlänge beträgt in diesem Beispiel 8.

## Generatoren für gleichverteilte Zufallszahlen

### Mersenne-Twister
Der Mersenne-Twister wurde 1997 von Makoto Matsumoto und Takuji Nishimura Im Jahr 1997 entwickelt und ist eine Weiterentwicklung des TGFSR (Twisted The Generalized Feedback Shift Register). Er wurde mit einer sehr langen Periodenlänge von $p = 2^{19937} - 1$ erweitert, die eine Mersenne-Primzahl ist. Weiterhin zählt der Mersenne-Twister zu den gleichverteilten Pseudozufallszahlengeneratoren.

Der \textbf{Algorithmus} startet mit $N = 624$ verschiedene Wörter, die mit $Y_1\ ...\ Y_N$ bezeichnet werden. Die Initialwörter können von einem anderen Pseudozufallszahlengenerator generiert werden. Hierbei muss drauf geachtet werden, dass nicht zuviele Wörter mit 0 initialisiert werden. Sind die Initialwörter gewählt, berechnet der Mersenne-Twister die weiteren Pseudzufallszahlen wie folgt.

$$h := Y_{i-N} - Y_{i-N}\ mod\ 2^{31} + Y_{i-N+1}\ mod\ 2^{31}$$
$$Y_i := Y_{i-227}\ \oplus \lfloor h/2 \rfloor\ \oplus\ ((h mod 2)\ \cdot\ 9908B0DF_{hex})$$

Weiterhin wird durch die nächsten Formeln die Gleichverteilung sichergegestellt.

$$x := Y_i\ \oplus\ \lfloor Y_i / 2^{11}\rfloor$$
$$y := x\ \oplus\ ((x\ \cdot\ 2^7)\ \wedge\ 9D2C5680_{hex}$$
$$z := y\ \oplus\ ((y\ \cdot\ 2^15)\ \wedge\ EFC60000_{hex}$$
$$Z_i := z\ \oplus\ \lfloor z / 2^{18}\rfloor$$

$Z_i$ ist eine Zufallszahl.

Bemerkungen:

* Durch die Bitoperationen ist der Algorithmus sehr schnell.
* Die Parallelisierung ist leicht zu realisieren.
* Der Generator benötigt ca. 2,5 kByte, welches auf kleineren Systemen mit wenig Cache zu Performanceeinbußen kommt.
* Der Mersenne-Twister wird in R als Standardpseudozufallszahlengenerator benutzt.
* Der Mersenne-Twister ist für viele Anwendungen ein Standard-Verfahren, unteranderem ist er in R, Stata, Microsoft Excel & Mathematica implementiert.

### Mittquadratverfahren
Das \textbf{Mittquadratverfahren (engl.: Middle-Square method)} ist ein einfacher Algorithmus zur Erzeugung gleichverteilter (Pseudo)Zufallszahlen. Er wurde 1946 von John von Neumann entwickelt. Wie der Name schon sagt, wird beim Mittquadrateverfahren die mittleren entnommen und quadriert.

$$x_{n+1} := mittlere\ acht\ Ziffern\ von\ x^2_n$$

Dabei wird der Initialwert aus $x_n \in \{0,1...,10^8\}$ gewählt, wobei die linke Seite mit $0$len aufgefüllt wird.

Bemerkungen:

* Der Algorithmus hat offensichtlich Probleme mit $x_n = 0$.
* Die Periodenlänge ist nicht groß.
* Verwendung als Hash-Funktion.
* siehe: Shiny app

### Sonstige

Die folgende Liste enthält weitere gleichverteilte Pseudozufallsgeneratoren.

* Lineare Kongruenzgeneratoren
* Schieberegister-Generatoren
* Tausworthe-Generatoren
* Kombinieren verschiedener Generatoren
* Inverse Kongruenzgeneratoren

## Generatoren für sonstige Verteilungen
Für den Fall, dass 

### Inversionsmethode
Mit Hilfe der \textbf{Inversionsmethode (engl.: Inverse transform sampling)} lassen sich (fast) beliebige diskrete und stetige Wahrscheinlichkeitsverteilungen aus gleichverteilten Zufallszahlen erzeugen. Diesem Generator liegt das \textbf{Simulationslemma} zugrunde, das besagt, dass

\emph{Beispiel:} Simulation der Exponentialverteilung $exp(\alpha)$
Die Verteilung mit der Dichte $f(t)=\alpha e^{-\alpha t}$ für $\alpha > 0, t>0$ und der Verteilungsfunktion $F(t)=1-e^{-\alpha e}$ mit $t>0$.


Auch wenn sich so theoretisch alle Verteilungen simulieren lassen, scheitert diese Methode in der Praxis daran, dass sich deren Quantilfunktion (z.B. bei ) nicht effizient berechnen lässt.





### Sonstige Methoden
Neben den Vorgestellten Methoden, gibt es noch eine ganze Reihe weitere Generatoren für speziell verteilte Zufallszahlen.

* \textbf{Verwerfungsmethode (engl.: Rejection sampling)}: Alternative zur Inversionsmethode, für Wahrscheinlichkeitsverteilungen, die zu komplex zu berechnen sind.

* \textbf{Kompositionsmethode}: 

# Güte eines Zufallszahlengenerators
Stell dir vor, du hast eben einen Zufallsgenerator kreiert und möchtest wissen, wie dieser im Gegensatz zu den bereits bestehenden Generatoren performt. Du möchstest demnach die Güte (Qualität) deines Zufallsgenerators beurteilen können. Michael Kolonk unterteilt dieses große Gebiet in die zwei Kriterien das \textbf{analytische Gütekriterium} und das \textbf{statistische Gütekriterium}.

## Analytische Gütekriterien
Im Gegensatz zu den statistischen Gütekriterium macht das \textbf{analytische Gütekriterium} über spezielle Zufallzahlengeneratoren starke Aussagen über die Güte. Jedoch bringt dies das Problem mit sich, dass diese Aussagen nur über diesen speziellen Generator gelten und daher für den Vergleich mit weiteren Generatoren nicht ideal ist. In diesem Fall wird versucht die Güte anhand eines Modells im Vergleich zum Zufallsexperiment anzunähern und mit vergleichbaren Eigenschaften wird versucht die Güte zu überprüfen.

Einer dieser vergleichbaren Eigenschaften kann die Überprüfung auf die Gleichverteilung sein. Dabei wird die Verteilung $X_0,...,X{d-1}$ für alle $d \ge 1$ mit der Gleichverteilung $[0,1]^d$ verglichen und sollte bestmöglich über ein stimmen. Sei $(X_n){n\ge0}$ eine Folge von Zufallsvariablen mit den Werten in $[0,1]$. $(X_n){n\ge0}$ ist i.i.d mit der Verteilung $U(0,1)$, falls fir alle $d \in \mathbb{N}$ und alle $0 \le a_i \le b_i \le 1, i = 0,...,d-1$, gilt

$$ P(a_i < X_i \le b_i, i = 0,...,d-1) = \prod_{i=0}^{d-1}(b_i-a_i)$$
Dabei unterscheiden sich die Untersuchungen in die zwei grundsätzlich Gebiete empirisch und analytisch. Die \textbf{empirische Unterschung} nimmt ein bestehendes mathemathisches Modell an und überprüft, ob die beobachteten Ereignisse von Zufallszahlen mit den mathematischen Modell zusammen passt. Dabei besteht die Möglichkeit diese Untersuchung graphisch oder statistisch durchzuführen. Folgende Einschrunkungen muss die die empirischen Untersuchung hinnehmen.

* Es besteht nur die Möglichkeit endlich viele Bedingungen zu überprüfen 
* Die obere Foderung ist zu stark und kann nur approximiert werden
<!-- Hier gibt es noch eine weitere Einschränkung -->

Die \textbf{analytische Untersuchung} versucht die Gütes des Zufallsgenerators anhand mathematischer-analystischer Methoden nachzuweisen.

### d-gleichverteilte Folgen
Wie im vorigen Kapitel angesprochen, kann nur eine endliche Zahlenfolge $(x_n)_{n \ge 0}$ mit einer Länge $d$ überprüft werden kann. Sollte die Beobachtung wiederholt werden und unabhängig sein, sollten die Teilstücke disjunkt gewählt werden. 

Weiterhin existiert die Möglichkeit, dass die Zahlenfolgen sich schneiden können. $\tilde{x}_i$ ist für  in der Form

$$\tilde{x}_i := (x_{ik}, x_{ik+1},...,x_{ik+d-1}),\quad i = 0,1,...$$
überlappend. Wenn

* $1 \le k \le d - 1$ für $\tilde{x}_i$ gilt,  die Teilstücke überlappend, wenn
* $k = d$ gilt, sind die Teilstücke disjunkt und lückenlos sind, wenn
* $k > d$ gilt, sind die Teilstücke disjunkt und gespreizt sind. 

### Graphische Überprüfung der Gleichverteilung
Jetzt gilt die vorgeschlagenen Bedingungen anhand von graphischen Mitteln zu untersuchen. Als Beispiel wurde der Mersenne-Twister, Super-Duper und PP-Coincidence ausgewählt. Alle ausgewählten Verfahren sollten nach Möglichkeit gleichverteilt nach der Verteilung $U(0,1)$ erfüllen. 

Der \textbf{Mersenne-Twister} arbeitet mit einer Periodenlänge von $p = 2^{19937} - 1$. Wie der Name schon sagt, ist das eine Mersenne-Prinzahl. Der Pseudozufallszahlengenerator \textbf{Super-Duper} wurde in den 70ger Jahren erfunden und arbeitet mit einer Periodenlänge von $p = 6*10^{18}$. Als dritten Generator wurde der \textbf{Wichmann-Hill} verwendet. Er generiert Zufallszahlen mit einer Periodenlänge von mehr als $6.95 * 10^{12}$.

Unterteilt werden die Zufallszahlenergebnisse jedes Verfahren in $2^5$ gleich große Teilintervalle $I_0,...,I_{31}$. Durch die Unterteilung besteht die Möglichkeit die Anzahl der Vorkommnisse in jeden Teilintervall mit der Formel
$$h_i := \displaystyle\sum_{n=0}^{N-1} 1_{I_i}(u_n)$$
zu berechnen. Die relativen Häufigkeiten können für jedes Intervall mit $\dfrac{h_i}{N}$ bestimmt werden.

```{r, echo=FALSE}
library(ggplot2)
numberOfRandomNumbers <- 10000

RNGkind("Mersenne-Twister") # matches  "Mersenne-Twister"
datamt = data.frame(data = runif(numberOfRandomNumbers), KindOfRandom = "Mersenne-Twister", pos = 1:numberOfRandomNumbers)

RNGkind("Super") # matches  "Super-Duper"
datasd = data.frame(data = runif(numberOfRandomNumbers), KindOfRandom = "Super-Duper", pos = 1:numberOfRandomNumbers)

RNGkind("Wichmann-Hill") # matches  "Wichmann-Hill"
datawh = data.frame(data = runif(numberOfRandomNumbers), KindOfRandom = "Wichmann-Hill", pos = 1:numberOfRandomNumbers)

data <- rbind(datamt, datasd, datawh)

ggplot(data, aes(x = data, color = KindOfRandom, fill = KindOfRandom)) + 
  geom_histogram(bins = 32) + 
  facet_grid(~ KindOfRandom) +
  theme(legend.direction = "horizontal", 
        legend.position = "bottom",
        legend.box = "horizontal") +
  labs(title = "Unterschiedliche Zufallszahlengeneratoren pro Histogramm (Verteilung)",
  x = "Generierte 10000 Zufallszahlen (32er Bins)",
  y = "Anzahl der Zufallszahlen pro Bin")
```

Die obige Abbildung visualisiert die drei genannten Pseudozufallszahlengeneratoren mit einer Anzahl von jeweils $N = 10000$ Zahlen pro Generator in einem Histrogramm. Die Zahlen wurden in 32er Bins eingeteilt mit $i = \{1, ..., 32\}$. Da alle drei Generatoren $U(0,1)$ sind, müsste die Anzahl der Zufallszahlen pro bin mit $\dfrac{N}{max(i)} = 312,5$ annährend berechnen lassen. Wird dazu die obige Abbildung gegengestellt, kann subjektiv erkannt werden, dass sich bis auf die äußeren Bins alle weiteren sich in dem errechneten Bereich bewegen. 

Allerdings birgt die Prüfung auf Gleichverteilung durch dieser Art der Visualisierung einer Gefahr. Denn der Generator $x_{n+1} = (x_n + 1)\ MOD\ M$ erzeugt eine ideale Gleichverteilung.

```{r, echo=FALSE}
ggplot(data, aes(y = data, x = pos, color = KindOfRandom)) + 
  geom_point(size = 0.01) +
  facet_grid(~ KindOfRandom) +
  theme(legend.direction = "horizontal", 
        legend.position = "bottom",
        legend.box = "horizontal") +
  labs(title = "Unterschiedliche Zufallszahlengeneratoren als Plot",
  x = "Zufallszahlen",
  y = "Spannweite des Zufallsgenerators")
```

Die obige Abbildung zeigt einen Plot von den drei behandelten Pseudozufallsgeneratoren. Zwischen $x$ und $y$ sollte es keinerlei Zusammenhang geben, da die generierte Zufallszahl $y$ möglichst unabhängig von seiner Position $x$ sein soll. Entstehen in einem derartigen Plot wiederkehrende Muster ist der Generator nicht optimal. Im gegebenen Fall entstehen keine Hinweise auf Muster, die Fläschen sehen gleichmäßig aus.

## Statistische Gütekriterien



# Zufallszahlen in R
In bestimmten Situationen werden in R Zufallszahlen benötigt. R bietet dafür verschiedene Pseudzufallszahlengeneratoren, die direkt in R ausgewählt werden können. Dabei besteht die Möglichkeit vor dem Aufruf eines Generators einen sogenannten \textbf{Seed} festzulegen. Ein Seed ermöglicht dem Nutzer eine Rekonstruierung der generierten Zufallszahlen nach jeden Aufruf. Wird bei einem Aufruf kein Seed gesetzt, wird einer zufällig generiert. Weitere Informationen können über den folgenden Befehl abgerufen werden.

```{r}
#?RNG
```

R stellt die folgenden Pseudozufallsgeneratoren nativ zur Verfügung.

  * Wichmann-Hill
  * Marsaglia-Multicarry
  * Super-Duper
  * Marsenne-Twister
  * Knuth-TAOCP-2002
  * Knuth-TAOCP
  * L'Ecuyer-CMRG
  * RNGkind() bietet die Möglichkeit einen eigenen Zufallszahlengenerator zu programmieren.

## Auswahl der RNG in R

```{r results='hide'}
# RNGkind setzt den Pseudozufallsgenerator
# Setzt den Zufallsgenerator auf L'Ecuyer-CMRG
RNGkind("L'Ecuyer-CMRG")

# Gibt den aktuellen Zufallsgenerator aus
RNGkind()

# Setzt den Zufallsgenerator auf Mersenne-Twister (default)
RNGkind("Mersenne-Twister")
```

## Setzen eines Seeds (optional)
```{r results='hide'}
# Setzt den Seed auf 123456789 für genau den nächsten Aufruf
set.seed(123456789)

# Generiert immer die selben 10 Zufallszahlen wegen den seed.
runif(10)

# Generiert 10 Zufallszahlen ohne Seed
runif(10)
```



## Eigene RNG
### PP-Coincidence
```{r, echo=FALSE}
#options(expressions=100000)
# Berechnet die neue Zufallszahl
#PP.Coincidence.CalculateNumber <- function (randomNumber) {
#  first <- as.numeric(substr(randomNumber, 0, 5))
#  second <- as.numeric(substr(randomNumber, 6, 10))
#  
#  if(is.na(second) || second == 0) {
#    second <- bitwXor(first, as.numeric(substr(as.numeric(Sys.time()), 6, 10)))
#  }
#  return (first * second)
#}

# Rekursiver Aufrauf
#PP.Coincidence.Recursive <- function(numberOfRandomNumbers, randomNumber, randomList) {
#  if (numberOfRandomNumbers <=0 ) {
#    return( c() )
#  } else {
#    newRN <- PP.Coincidence.CalculateNumber(randomNumber)
#    return( c(Recall(numberOfRandomNumbers-1, newRN, randomList),newRN/10000000000) )
#  }
#}

# Initialaufruf mit einer Anzahl von Zufallszahlen
#PP.Coincidence <- function(numberOfRandomNumbers){
#  return (PP.Coincidence.Recursive(numberOfRandomNumbers, as.numeric(Sys.time()), c()))
#}
```
## Prüfung auf Unabhängigkeit der Zufallszahlen


# Quellen

[1] [J.E._Gentle,_Wolfgang_HSrdle,_James_E._Gentle

[2] Severin Schürz http://www.fim.uni-linz.ac.at/Lva/Web_Security/Abgaben/Schuerz-RNG.pdf

[3] Michael Kolonk, Stochastische Simulation

[4] Makoto Matsumoto, Twisted GFSR Generators, http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/tgfsr3.pdf

[5] Makoto Matsumoto, Mersenne Twister, http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf